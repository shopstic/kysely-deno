import {
  ColumnType,
  Generated,
  InsertObject,
  Kysely,
  SelectQueryBuilder,
  sql,
} from "https://esm.sh/kysely@0.23.4?pin=v106";

type ExpandRecursively<T> = T extends (...args: infer A) => infer R
  ? (...args: ExpandRecursively<A>) => ExpandRecursively<R>
  : T extends Date ? T
  // deno-lint-ignore ban-types
  : T extends object ? T extends infer O ? { [K in keyof O]: ExpandRecursively<O[K]> }
    : never
  : T;

function expandType<T>(value: T) {
  return value as ExpandRecursively<typeof value>;
}

export interface PersonTable {
  // Columns that are generated by the database should be marked
  // using the `Generated` type. This way they are automatically
  // made optional in inserts and updates.
  id: Generated<number>;

  firstName: string;
  gender: "male" | "female" | "other";

  // If the column is nullable in the database, make its type nullable.
  // Don't use optional properties. Optionality is always determined
  // automatically by Kysely.
  lastName: string | null;

  // You can specify a different type for each operation (select, insert and
  // update) using the `ColumnType<SelectType, InsertType, UpdateType>`
  // wrapper. Here we define a column `modified_at` that is selected as
  // a `Date`, can optionally be provided as a `string` in inserts and
  // can never be updated:
  createdAt: ColumnType<Date, Date, never>;
}

export interface PetTable {
  id: Generated<number>;
  name: string;
  ownerId: number;
  species: "dog" | "cat";
}

export interface MovieTable {
  id: Generated<string>;
  stars: number;
}

export interface FoodTable {
  id: Generated<string>;
  name: string;
  bestFor: "cat" | "dog";
}

export interface PetFoodTable {
  petId: number;
  foodId: number;
}

// Keys of this interface are table names.
export interface Database {
  person: PersonTable;
  pet: PetTable;
  movie: MovieTable;
  food: FoodTable;
  petFood: PetFoodTable;
}

export async function upSqlite(db: Kysely<unknown>): Promise<void> {
  await db.schema
    .createTable("person")
    .addColumn("id", "integer", (c) => c.primaryKey().autoIncrement())
    .addColumn("firstName", "text", (c) => c.notNull())
    .addColumn("lastName", "text")
    .addColumn("gender", "text", (c) => c.notNull())
    .addColumn("createdAt", "text", (c) => c.notNull())
    .execute();

  await db.schema
    .createTable("pet")
    .addColumn("id", "integer", (c) => c.primaryKey().autoIncrement())
    .addColumn("name", "text", (c) => c.notNull().unique())
    .addColumn(
      "ownerId",
      "integer",
      (c) => c.references("person.id").onDelete("cascade").notNull(),
    )
    .addColumn("species", "text", (c) => c.notNull())
    .execute();

  await db.schema
    .createIndex("pet_owner_id_index")
    .on("pet")
    .column("ownerId")
    .execute();
}

export async function upPostgres(db: Kysely<unknown>): Promise<void> {
  await db.schema
    .createTable("person")
    .addColumn("id", "serial", (c) => c.primaryKey())
    .addColumn("firstName", "varchar", (c) => c.notNull())
    .addColumn("lastName", "varchar")
    .addColumn("gender", "varchar(50)", (c) => c.notNull())
    .addColumn("createdAt", "timestamp", (c) => c.notNull())
    .execute();

  await db.schema
    .createTable("pet")
    .addColumn("id", "serial", (c) => c.primaryKey())
    .addColumn("name", "varchar", (c) => c.notNull().unique())
    .addColumn(
      "ownerId",
      "integer",
      (c) => c.references("person.id").onDelete("cascade").notNull(),
    )
    .addColumn("species", "varchar", (c) => c.notNull())
    .execute();

  await db.schema
    .createIndex("perOwnerIdIndex")
    .on("pet")
    .column("ownerId")
    .execute();

  await db.schema
    .createTable("food")
    .addColumn("id", "serial", (c) => c.primaryKey())
    .addColumn("name", "varchar", (c) => c.notNull().unique())
    .addColumn("bestFor", "varchar", (c) => c.notNull())
    .execute();

  await db.schema
    .createTable("petFood")
    .addColumn("petId", "integer", (c) => c.notNull().references("pet.id").onDelete("cascade"))
    .addColumn("foodId", "integer", (c) => c.notNull().references("food.id").onDelete("cascade"))
    .addPrimaryKeyConstraint("petFoodId", ["petId", "foodId"])
    .execute();

  await db.schema
    .createIndex("petFoodPersonIdIndex")
    .on("petFood")
    .column("petId")
    .execute();

  await db.schema
    .createIndex("petFoodFoodIdIndex")
    .on("petFood")
    .column("foodId")
    .execute();
}

export async function run(db: Kysely<Database>) {
  const result = await db.transaction().execute(async (tx) => {
    await tx
      .deleteFrom("person")
      .where((q) =>
        q
          .where("firstName", "!=", "foo")
          .where("lastName", "!=", "bar")
          .orWhere((q) =>
            q
              .where("firstName", "!=", "foo")
              .where("lastName", "!=", "bar")
          )
      )
      .execute();

    await tx
      .deleteFrom("food")
      .execute();

    const { id } = await tx
      .insertInto("person")
      .values({
        firstName: "Jennifer",
        lastName: "Lawrence",
        gender: "female",
        createdAt: new Date(),
      })
      .returning("id")
      .executeTakeFirstOrThrow();

    console.log("OWNER ID", id);
    // await delay(1000);

    const allPets = await tx
      .insertInto("pet")
      .values([{ name: "Catto", species: "cat", ownerId: id }, {
        name: "Doggo",
        species: "dog",
        ownerId: id,
      }])
      .returningAll()
      .execute();

    const allFood = await tx
      .insertInto("food")
      .values([{
        name: "fish",
        bestFor: "cat",
      }, {
        name: "milk",
        bestFor: "cat",
      }, {
        name: "bone",
        bestFor: "dog",
      }, {
        name: "beef",
        bestFor: "dog",
      }])
      .returningAll()
      .execute();

    const allPetFood: InsertObject<Database, "petFood">[] = allPets.flatMap((pet) =>
      allFood.filter(({ bestFor }) => pet.species === bestFor).map(({ id }) => ({
        petId: pet.id,
        foodId: Number(id),
      }))
    );

    await tx.insertInto("petFood")
      .values(allPetFood)
      .execute();

    // const people = await tx
    //   .selectFrom("person")
    //   .innerJoin("pet", "pet.ownerId", "person.id")
    //   // .selectAll()
    //   .select(["firstName", "pet.name as petName", "createdAt"])
    //   .where("person.id", "=", id)
    //   .execute();

    function jsonbAgg<DB, TB extends keyof DB, O>(
      qb: SelectQueryBuilder<DB, TB, O>,
    ) {
      return sql<O[]>`coalesce((select jsonb_agg(x) from (${qb}) x), '[]'::jsonb)`;
    }

    const people = expandType(
      await tx
        .selectFrom("person")
        .selectAll("person")
        .select((q1) =>
          jsonbAgg(
            q1
              .selectFrom("pet")
              .where("pet.species", "=", "dog")
              .whereRef("person.id", "=", "pet.ownerId")
              .selectAll("pet")
              .select((q2) =>
                jsonbAgg(
                  q2
                    .selectFrom("food")
                    .selectAll("food")
                    .innerJoin("petFood", "petFood.foodId", "food.id")
                    .whereRef("pet.id", "=", "petFood.petId"),
                ).as("food")
              ),
          ).as("pets")
        )
        .execute(),
    );

    return people;
  });

  result.forEach((person) => {
    console.log("person.firstName", person.firstName);
    console.log("person.createdAt", person.createdAt, person.createdAt instanceof Date);
    console.log("person.pets", person.pets);
  });
}
